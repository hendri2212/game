<!DOCTYPE html>
<html lang="id">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Webcam Arcade Shooter</title>
    <style>
        :root {
            --bg: #0b1020;
            --fg: #e8f0ff;
            --accent: #5de4c7;
            --danger: #ff6b6b;
            --muted: #94a3b8;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--fg);
            font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        }

        .wrap {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        /* Game canvas fills screen */
        #game {
            position: absolute;
            inset: 0;
            display: block;
            width: 100%;
            height: 100%;
            background: radial-gradient(1200px 600px at 50% 120%, #0f1630 0%, #0b1020 60%, #080b18 100%);
        }

        /* UI overlay */
        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: space-between;
            pointer-events: none;
        }

        .hud .left,
        .hud .right {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .chip {
            pointer-events: auto;
            background: rgba(255, 255, 255, .06);
            border: 1px solid rgba(255, 255, 255, .08);
            padding: 6px 10px;
            border-radius: 10px;
            backdrop-filter: blur(4px);
        }

        .chip strong {
            color: var(--accent);
        }

        .panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            gap: 8px;
            align-items: center;
            pointer-events: auto;
        }

        button,
        input[type="range"] {
            cursor: pointer;
        }

        button {
            background: #1f2937;
            color: var(--fg);
            border: 1px solid #334155;
            padding: 8px 12px;
            border-radius: 10px;
            font-weight: 600;
        }

        button:disabled {
            opacity: .5;
            cursor: not-allowed;
        }

        button.primary {
            background: #0ea5e9;
            border-color: #0284c7;
            color: #02131f;
        }

        .controls {
            position: absolute;
            right: 10px;
            bottom: 10px;
            display: grid;
            gap: 6px;
            padding: 10px;
            background: rgba(2, 10, 20, .6);
            border: 1px solid rgba(255, 255, 255, .08);
            border-radius: 12px;
            pointer-events: auto;
        }

        .row {
            display: grid;
            grid-template-columns: 120px 1fr;
            gap: 8px;
            align-items: center;
            color: var(--muted);
        }

        .row code {
            color: var(--fg);
        }

        #debug {
            width: 200px;
            height: 150px;
            image-rendering: pixelated;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, .08);
        }

        #video {
            display: none;
        }

        .help {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: 10px;
            color: var(--muted);
            opacity: .9;
            text-align: center;
        }

        .help kbd {
            background: #111827;
            border: 1px solid #374151;
            padding: 2px 6px;
            border-radius: 6px;
            font-weight: 600;
        }
    </style>
</head>

<body>
    <div class="wrap">
        <canvas id="game"></canvas>

        <!-- HUD -->
        <div class="hud">
            <div class="left">
                <div class="chip">Skor: <strong id="score">0</strong></div>
                <div class="chip">Tembakan: <strong id="shots">0</strong></div>
                <div class="chip">Akurasi: <strong id="acc">0%</strong></div>
            </div>
            <div class="right">
                <div class="chip" id="status">‚è≥ Kamera belum menyala</div>
            </div>
        </div>

        <!-- Bottom-left panel -->
        <div class="panel">
            <button id="startBtn" class="primary">üé• Start Camera</button>
            <button id="calBtn">üéØ Kalibrasi Warna (klik pada video)</button>
            <canvas id="debug" width="160" height="120" title="Preview & deteksi"></canvas>
        </div>

        <!-- Right controls -->
        <div class="controls">
            <div class="row"><span>Hue target</span><input id="hue" type="range" min="0" max="359" value="120" /></div>
            <div class="row"><span>Toleransi (¬∞)</span><input id="tol" type="range" min="2" max="45" value="16" /></div>
            <div class="row"><span>Min Saturation</span><input id="smin" type="range" min="0" max="100" value="40" />
            </div>
            <div class="row"><span>Min Value</span><input id="vmin" type="range" min="0" max="100" value="50" /></div>
            <div class="row"><span>Min Area</span><input id="amin" type="range" min="10" max="1000" value="120" /></div>
            <div class="row"><span>Mode Trigger</span><code id="trigMode">Tutup‚Äëbuka ujung</code></div>
        </div>

        <div class="help">Menembak: tutup‚Äëbuka ujung warna cepat <em>atau</em> tekan <kbd>Space</kbd>. | Tips: tempel
            stiker neon di ujung benda.</div>

        <video id="video" playsinline></video>
    </div>

    <script>
        (() => {
            // ====== Elements ======
            const video = document.getElementById('video');
            const game = document.getElementById('game');
            const gctx = game.getContext('2d', { alpha: false });
            const debug = document.getElementById('debug');
            const dctx = debug.getContext('2d', { willReadFrequently: true });

            const scoreEl = document.getElementById('score');
            const shotsEl = document.getElementById('shots');
            const accEl = document.getElementById('acc');
            const statusEl = document.getElementById('status');

            const startBtn = document.getElementById('startBtn');
            const calBtn = document.getElementById('calBtn');

            // Controls
            const hueIn = document.getElementById('hue');
            const tolIn = document.getElementById('tol');
            const sminIn = document.getElementById('smin');
            const vminIn = document.getElementById('vmin');
            const aminIn = document.getElementById('amin');

            const DET_W = debug.width;  // 160
            const DET_H = debug.height; // 120

            // ====== State ======
            const state = {
                running: false,
                pointer: { x: 0, y: 0, has: false, rawX: 0, rawY: 0 },
                lastTime: performance.now(),
                matchCount: 0,
                prevMatch: 0,
                armed: false,
                lastCoverAt: 0,
                shots: 0,
                hits: 0,
                targets: [],
                particles: [],
                targetHue: 120, // default: hijau neon
                tol: 16,
                smin: 0.40,
                vmin: 0.50,
                amin: 120,
                smoothing: 0.25,
            };

            // Audio (beep on fire/hit)
            let audioCtx;
            function beep(freq = 660, ms = 80, vol = 0.12) {
                try {
                    audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
                    const o = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    o.frequency.value = freq; o.type = 'square';
                    g.gain.value = vol; o.connect(g); g.connect(audioCtx.destination);
                    o.start(); setTimeout(() => { o.stop(); }, ms);
                } catch (_) { }
            }

            // ====== Utils ======
            const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
            const lerp = (a, b, t) => a + (b - a) * t;
            function dist2(ax, ay, bx, by) { const dx = ax - bx, dy = ay - by; return dx * dx + dy * dy; }

            function rgbToHsv(r, g, b) {
                r /= 255; g /= 255; b /= 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, v = max; const d = max - min; s = max === 0 ? 0 : d / max;
                if (d === 0) h = 0; else {
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        default: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return { h: Math.round(h * 360), s, v };
            }

            function hueMatch(h, center, tol) {
                let d = Math.abs(h - center); if (d > 180) d = 360 - d; return d <= tol;
            }

            function updateControlsFromState() {
                hueIn.value = state.targetHue;
                tolIn.value = state.tol;
                sminIn.value = Math.round(state.smin * 100);
                vminIn.value = Math.round(state.vmin * 100);
                aminIn.value = state.amin;
            }
            updateControlsFromState();

            function readControlsToState() {
                state.targetHue = +hueIn.value | 0;
                state.tol = +tolIn.value | 0;
                state.smin = (+sminIn.value | 0) / 100;
                state.vmin = (+vminIn.value | 0) / 100;
                state.amin = +aminIn.value | 0;
            }

            hueIn.oninput = tolIn.oninput = sminIn.oninput = vminIn.oninput = aminIn.oninput = readControlsToState;

            // ====== Camera ======
            async function startCamera() {
                if (!navigator.mediaDevices?.getUserMedia) {
                    statusEl.textContent = '‚ùå getUserMedia tidak didukung browser ini';
                    return;
                }
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: 'environment' }, audio: false });
                    video.srcObject = stream; await video.play();
                    statusEl.textContent = '‚úÖ Kamera aktif';
                    startBtn.disabled = true;
                    state.running = true;
                    onResize();
                    requestAnimationFrame(loop);
                } catch (err) {
                    console.error(err);
                    statusEl.textContent = '‚ùå Akses kamera ditolak atau gagal';
                }
            }

            startBtn.addEventListener('click', startCamera);

            // ====== Resize ======
            function onResize() {
                game.width = game.clientWidth;
                game.height = game.clientHeight;
            }
            addEventListener('resize', onResize);

            // ====== Detection (color centroid) ======
            let calibrating = false;
            calBtn.addEventListener('click', () => {
                calibrating = !calibrating;
                calBtn.textContent = calibrating ? 'üõ†Ô∏è Klik pada preview untuk set warna' : 'üéØ Kalibrasi Warna (klik pada video)';
            });

            debug.addEventListener('click', (ev) => {
                if (!calibrating) return;
                const rect = debug.getBoundingClientRect();
                const x = clamp(Math.round((ev.clientX - rect.left) * debug.width / rect.width), 0, debug.width - 1);
                const y = clamp(Math.round((ev.clientY - rect.top) * debug.height / rect.height), 0, debug.height - 1);
                const img = dctx.getImageData(0, 0, debug.width, debug.height);
                const idx = (y * img.width + x) * 4;
                const r = img.data[idx], g = img.data[idx + 1], b = img.data[idx + 2];
                const { h, s, v } = rgbToHsv(r, g, b);
                state.targetHue = h;
                state.smin = Math.max(0.25, Math.min(0.85, s * 0.9));
                state.vmin = Math.max(0.35, Math.min(0.95, v * 0.9));
                updateControlsFromState();
                calibrating = false;
                calBtn.textContent = 'üéØ Kalibrasi Warna (klik pada video)';
            });

            function detectPointer() {
                if (!state.running || video.readyState < 2) return;
                // Draw small video to debug canvas for cheap processing
                dctx.drawImage(video, 0, 0, DET_W, DET_H);
                const img = dctx.getImageData(0, 0, DET_W, DET_H);
                let count = 0, sumX = 0, sumY = 0;

                const { targetHue, tol, smin, vmin } = state;
                const w = img.width, h = img.height, data = img.data;
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const i = (y * w + x) * 4;
                        const r = data[i], g = data[i + 1], b = data[i + 2]; // ignore alpha
                        const { h: hh, s, v } = rgbToHsv(r, g, b);
                        if (v > vmin && s > smin && hueMatch(hh, targetHue, tol)) {
                            sumX += x; sumY += y; count++;
                            // Tint matched pixels in preview for visual feedback
                            data[i] = 20; data[i + 1] = 255; data[i + 2] = 160;
                        } else {
                            // desaturate non-matches a bit
                            data[i] = data[i] * 0.5; data[i + 1] = data[i + 1] * 0.5; data[i + 2] = data[i + 2] * 0.5;
                        }
                    }
                }
                // Put back tinted preview
                dctx.putImageData(img, 0, 0);

                state.prevMatch = state.matchCount;
                state.matchCount = count;

                if (count >= state.amin) {
                    const cx = (sumX / count) / DET_W * game.width;
                    const cy = (sumY / count) / DET_H * game.height;
                    if (state.pointer.has) {
                        state.pointer.x = lerp(state.pointer.x, cx, state.smoothing);
                        state.pointer.y = lerp(state.pointer.y, cy, state.smoothing);
                    } else {
                        state.pointer.x = cx; state.pointer.y = cy;
                    }
                    state.pointer.rawX = cx; state.pointer.rawY = cy; state.pointer.has = true;
                } else {
                    state.pointer.has = false;
                }
            }

            // Trigger by quick cover-uncover (match area drops then recovers quickly)
            function pollTrigger(now) {
                const prev = state.prevMatch, cur = state.matchCount;
                const drop = (prev > 0) ? (cur / prev) : 1;

                if (!state.armed && prev > state.amin && drop < 0.45) {
                    state.armed = true; state.lastCoverAt = now;
                }
                // recover within 300ms
                if (state.armed && cur > prev * 0.85 && (now - state.lastCoverAt) < 300) {
                    state.armed = false; return true;
                }
                // timeout
                if (state.armed && (now - state.lastCoverAt) > 400) state.armed = false;
                return false;
            }

            // ====== Game objects ======
            function spawnTarget() {
                const r = 26 + Math.random() * 24;
                const margin = Math.max(40, r + 10);
                const x = margin + Math.random() * (game.width - margin * 2);
                const y = margin + Math.random() * (game.height - margin * 2);
                const ttl = 5 + Math.random() * 4; // seconds
                const hue = 200 + Math.random() * 100;
                state.targets.push({ x, y, r, ttl, hue });
            }

            function explode(x, y) {
                for (let i = 0; i < 18; i++) {
                    const a = Math.random() * Math.PI * 2; const sp = 60 + Math.random() * 140;
                    state.particles.push({ x, y, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp, life: .35 + Math.random() * .35 });
                }
            }

            function fire() {
                if (!state.pointer.has) return;
                state.shots++; beep(720, 60, 0.12);
                // check hits (closest first)
                const px = state.pointer.x, py = state.pointer.y;
                let hitIdx = -1, hitDist2 = Infinity;
                for (let i = 0; i < state.targets.length; i++) {
                    const t = state.targets[i];
                    const d2 = dist2(px, py, t.x, t.y);
                    if (d2 <= t.r * t.r && d2 < hitDist2) { hitIdx = i; hitDist2 = d2; }
                }
                if (hitIdx >= 0) {
                    const t = state.targets[hitIdx];
                    state.targets.splice(hitIdx, 1);
                    state.hits++; explode(t.x, t.y); beep(220, 90, 0.18);
                    // respawn quickly to keep flow
                    setTimeout(spawnTarget, 250 + Math.random() * 300);
                }
                updateHud();
                // Muzzle flash particle at pointer
                explode(px, py);
            }

            addEventListener('keydown', (e) => { if (e.code === 'Space') { e.preventDefault(); fire(); } });

            function updateHud() {
                scoreEl.textContent = state.hits;
                shotsEl.textContent = state.shots;
                const acc = state.shots ? Math.round((state.hits / state.shots) * 100) : 0;
                accEl.textContent = acc + '%';
            }

            // ====== Main loop ======
            function loop(now) {
                if (!state.running) return;
                const dt = Math.min(0.05, (now - state.lastTime) / 1000); // clamp 50ms
                state.lastTime = now;

                detectPointer();

                // Automatic target population
                while (state.targets.length < 4) spawnTarget();

                // Update objects
                for (let i = state.targets.length - 1; i >= 0; i--) {
                    const t = state.targets[i]; t.ttl -= dt;
                    if (t.ttl <= 0) state.targets.splice(i, 1);
                }

                for (let i = state.particles.length - 1; i >= 0; i--) {
                    const p = state.particles[i];
                    p.life -= dt; p.x += p.vx * dt; p.y += p.vy * dt; p.vx *= 0.96; p.vy *= 0.96;
                    if (p.life <= 0) state.particles.splice(i, 1);
                }

                // Trigger detection from webcam
                if (pollTrigger(now)) fire();

                // Draw
                draw();

                requestAnimationFrame(loop);
            }

            function draw() {
                const w = game.width, h = game.height;
                gctx.clearRect(0, 0, w, h);

                // Targets
                for (const t of state.targets) {
                    const alpha = clamp(t.ttl / 1.5, 0.25, 1);
                    gctx.save();
                    gctx.globalAlpha = alpha;
                    gctx.beginPath(); gctx.arc(t.x, t.y, t.r, 0, Math.PI * 2); gctx.closePath();
                    const grad = gctx.createRadialGradient(t.x - 4, t.y - 4, t.r * 0.1, t.x, t.y, t.r);
                    grad.addColorStop(0, `hsl(${t.hue}, 90%, 65%)`);
                    grad.addColorStop(1, `hsl(${t.hue}, 90%, 40%)`);
                    gctx.fillStyle = grad; gctx.fill();
                    // outline + countdown ring
                    gctx.lineWidth = 3; gctx.strokeStyle = 'rgba(255,255,255,.35)'; gctx.stroke();
                    const frac = clamp(t.ttl / 9, 0, 1);
                    gctx.beginPath(); gctx.strokeStyle = 'rgba(255,255,255,.6)'; gctx.arc(t.x, t.y, t.r + 4, -Math.PI / 2, -Math.PI / 2 + frac * 2 * Math.PI); gctx.stroke();
                    gctx.restore();
                }

                // Particles
                for (const p of state.particles) {
                    gctx.globalAlpha = clamp(p.life / 0.35, 0, 1);
                    gctx.fillStyle = '#ffe08a';
                    gctx.fillRect(p.x, p.y, 2, 2);
                }
                gctx.globalAlpha = 1;

                // Crosshair / cursor
                if (state.pointer.has) {
                    const x = state.pointer.x, y = state.pointer.y;
                    gctx.save();
                    gctx.translate(x, y);
                    gctx.strokeStyle = '#e5fbff'; gctx.lineWidth = 2;
                    gctx.beginPath(); gctx.arc(0, 0, 18, 0, Math.PI * 2); gctx.stroke();
                    gctx.beginPath(); gctx.moveTo(-26, 0); gctx.lineTo(-10, 0); gctx.moveTo(10, 0); gctx.lineTo(26, 0);
                    gctx.moveTo(0, -26); gctx.lineTo(0, -10); gctx.moveTo(0, 10); gctx.lineTo(0, 26); gctx.stroke();
                    gctx.restore();
                } else {
                    // Hint when not tracking
                    gctx.fillStyle = 'rgba(255,255,255,.15)';
                    gctx.textAlign = 'center'; gctx.textBaseline = 'middle'; gctx.font = '600 18px system-ui';
                    gctx.fillText('Arahkan ujung benda berwarna ke kamera ¬∑ klik ‚ÄúKalibrasi‚Äù lalu klik warna di preview', w / 2, h / 2);
                }
            }

            // ====== Kick ======
            // Warn about https
            if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                statusEl.textContent = '‚ÑπÔ∏è Jalankan di https:// atau http://localhost untuk akses kamera.';
            }

            updateHud();
        })();
    </script>
</body>

</html>